# JAVA Collection FrameWork

> 자바의 컬렉션 프레임워크는 Object( 객체 )만 저장이 가능하다.<br>
> 그래서 int,double같은 primitive 타입의 값을 저장하려면 Integer,Double 객체로 박싱 ( Boxing )하여 저장해야 한다.<br>
> 또한 객체를 담는다는 것은 주소값을 담는다는 것이니, Null값도 저장이 가능하다.


### 컬렉션 프레임워크는 크게 Collection 인터페이스 , Map 인터페이스로 나뉜다.
>대부분의 컬렉션은 List,Set,Map 중의 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스 이름에 포함되는 특징이 있다.<br/>
>그러나 Vector , Stack , HashTable , Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것들로<br/>
> 컬렉션 프레임워크의 명명법을 따르지 않는다. 또한 Vector나 HashTable과 같은 기존의 컬렉션들은 호환을 위해 남겨진것으로 가급적 사용하지 않는게 좋다.




## Iterable 인터페이스
- Iterator란 자바의 컬렉션 프레임워크에서 컬렉션에 저장되어 있는 요소들을 읽어오는 방법을 표준화한 것
- Iterator는 반복자로서 객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료구조의 내부요소를 순회하는 객체
- 컬렉션 인터페이스들의 가장 최상위 인터페이스
- 컬렉션들을 배우다 보면 자료들을 순회할 때 이터레이터 객체를 다루게 되는데, 이 이터레이터 객체를 관리하는 인터페이스
   - forEach = 함수형 프로그래밍 전용 루프 메서드
   - iterator = 컬렉션에서 이터레이터를 구현
   - splierator = 파이프라이닝 관련 메소드


## Collection 인터페이스
- List , Set , Queue에 상속을 하는 실질적인 최상위 컬렉션 타입
- 업캐스팅으로 다양한 종류의 컬렉션 자료형을 받아 자료를 삽입하거나,삭제,탐색 기능을 할 수 있다 ( 다형성 )
  - add , addAll = 지정된 객체 또는 Collection의 객체들을 Collection에 추가
  - contains , containsAll = 지정된 객체 또는 Collection 객체들이 Collection에 포함되어 있는지 확인
  - remove , removeAll = 지정된 객체 또는 지정된 Collection에 포함된 객체들을 삭제
  - retainAll = 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제,
    - 사실상 removeAll의 대칭 버전 ( 교집합 ), 해당 작업으로 Collection에 변화가 있다면 true, 없다면 false 반환
  - clear = 모든 객체를 삭제
- JDK 1.8 부터 함수형 프로그래밍을 위한 parallelStream , removeIf , stream , forEach 디폴트 메서드가 추가

## List 인터페이스
- 저장 순서가 유지되는 컬렉션을 구현시 사용
- 같은 요소의 중복 저장을 허용
- 배열처럼 index로 요소에 접근
- 리스트와 배열의 차이는 리스트는 자료형 크기가 동적이고 배열은 정적이라는 것
- 요소 사이에 빈 공간을 허용하지 않아 삽입/삭제 시마다 배열 이동이 발생함

#### ArrayList 클래스
- 배열을 이동하여 만든 리스트
- 데이터의 저장순서가 유지되고 중복을 허용
- 데이터량에 따라 공간( Capacity )가 자동으로 늘어나거나 줄어듬
- 단반향 포인터 구조로 자료에 대한 순차적인 접근에 강점이 있어 조회가 빠름
- 하지만 삽입 / 삭제가 느리다. 단, 순차적으로 추가/삭제 하는 경우에 가장 빠르다
  - 중간에 데이터를 추가/삭제시에 해당 위치 이후의 데이터들에 대한 위치 변경이 필요하기 때문


#### LinkedList 클래스
- 노드 ( 객체 )를 연결하여 리스트처럼 만든 컬렉션 ( 배열이 아님 )
- 데이터의 중간 삽입/삭제가 빈번한 경우 빠른 성능을 보장
- 임의의 요소에 대한 접근 성능이 좋지않음
- 자바의 LinkedList는 Doubly LinkedList ( 양방향 포인터 )로 이루어져 있다.
- LinkedList는 리스트 용도 이외에도 스택 , 큐 , 트리 등의 자료구조의 근간이된다
- List 인터페이스와 Queue 인터페이스를 동시에 상속받고 있어, 스택 / 큐 로서도 응용이 가능
- 실제로 LinkedList 클래스는 큐 동작과 관련된 메서드를 지원한다.

#### Vector 클래스
- ArrayList의 구형 버전 ( 내부 구성이 비슷 )
- ArrayList와 차이점은, 모든 메소드가 동기화 ( Synchronized )되어있어, Thread-Safe하다
- 구버전 자바와 호환을 위해 남겨져 있으며, 잘  쓰이지는 않는다

#### Stack 클래스
- 후입 선출 ( LIFO ) 자료구조
- 마지막에 들어온 원소가 가장 먼저 출력된다
- 데이터를 넣을때는 push 출력할때는 pop이라는 용어를 사용
- Stack은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓰임, 대신 ArrayDeque를 사용한다

## Queue 인터페이스
- 선입 선출 ( FIFO ) 자료구조
- 처음 들어온 원소가 가장 먼저 출력
- 자바에서는 Queue는 인터페이스이고, 필요에 따라 큐 컬렉션을 골라서 사용할 수 있다.

#### PriorityQuery 클래스
- 우선 순위를 가지는 큐  ( 우선순위 큐 )
- 일반적인 큐와는 조금 다르게, 원소에 우선 순위(Priority)를 부여하여 우선순위가 높은 순으로 정렬되고 출력한다.
- 수행할 작업이 여러개 있고, 시간이 제한되어 있을 때 우선순위가 높은 것 부터 수행할 때 쓰인다. ( 네트워크 제어 , 작업 스케쥴링 등 )
- 우선순의 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현해야한다.
  - compareTo() 메서드 로직에 따라 자료객체의 우선순위를 결정하는 식으로 동작되기 때문
- 저장공간으로 배열을 사용하며, 각 요소를 힙(Heap) 형태로 저장
- Null은 저장이 불가능하다.

## Deque 인터페이스
- Deque ( Double-Ended Queue )는 양쪽으로 데이터를 넣고 뺄 수 있는 큐를 말한다.
- 스택과 큐를 하나로 합쳐놓은 것과 같으며, 스택으로 사용할 수도 있고, 큐로 사용할 수도 있다.
- Deque의 조상은 Queue이며, 구현체로 ArrayDeque와 LinkedList등이 있다.

#### ArrayDeque 클래스
- 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
- 사이즈에 제한이 없다
- Null요소는 저장되지 않는다.


