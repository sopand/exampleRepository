# JAVA Collection FrameWork

> 자바의 컬렉션 프레임워크는 Object( 객체 )만 저장이 가능하다.<br>
> 그래서 int,double같은 primitive 타입의 값을 저장하려면 Integer,Double 객체로 박싱 ( Boxing )하여 저장해야 한다.<br>
> 또한 객체를 담는다는 것은 주소값을 담는다는 것이니, Null값도 저장이 가능하다.


### 컬렉션 프레임워크는 크게 Collection 인터페이스 , Map 인터페이스로 나뉜다.
> 대부분의 컬렉션은 List,Set,Map 중의 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스 이름에 포함되는 특징이 있다.<br/>
> 그러나 Vector , Stack , HashTable , Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것들로<br/>
> 컬렉션 프레임워크의 명명법을 따르지 않는다. 또한 Vector나 HashTable과 같은 기존의 컬렉션들은 호환을 위해 남겨진것으로 가급적 사용하지 않는게 좋다.




## Iterable 인터페이스
- Iterator란 자바의 컬렉션 프레임워크에서 컬렉션에 저장되어 있는 요소들을 읽어오는 방법을 표준화한 것
- Iterator는 반복자로서 객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료구조의 내부요소를 순회하는 객체
- 컬렉션 인터페이스들의 가장 최상위 인터페이스
- 컬렉션들을 배우다 보면 자료들을 순회할 때 이터레이터 객체를 다루게 되는데, 이 이터레이터 객체를 관리하는 인터페이스
  - forEach = 함수형 프로그래밍 전용 루프 메서드
  - iterator = 컬렉션에서 이터레이터를 구현
  - splierator = 파이프라이닝 관련 메소드


## Collection 인터페이스
- List , Set , Queue에 상속을 하는 실질적인 최상위 컬렉션 타입
- 업캐스팅으로 다양한 종류의 컬렉션 자료형을 받아 자료를 삽입하거나,삭제,탐색 기능을 할 수 있다 ( 다형성 )
  - add , addAll = 지정된 객체 또는 Collection의 객체들을 Collection에 추가
  - contains , containsAll = 지정된 객체 또는 Collection 객체들이 Collection에 포함되어 있는지 확인
  - remove , removeAll = 지정된 객체 또는 지정된 Collection에 포함된 객체들을 삭제
  - retainAll = 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제,
    - 사실상 removeAll의 대칭 버전 ( 교집합 ), 해당 작업으로 Collection에 변화가 있다면 true, 없다면 false 반환
  - clear = 모든 객체를 삭제
- JDK 1.8 부터 함수형 프로그래밍을 위한 parallelStream , removeIf , stream , forEach 디폴트 메서드가 추가

## List 인터페이스
- 저장 순서가 유지되는 컬렉션을 구현시 사용
- 같은 요소의 중복 저장을 허용
- 배열처럼 index로 요소에 접근
- 리스트와 배열의 차이는 리스트는 자료형 크기가 동적이고 배열은 정적이라는 것
- 요소 사이에 빈 공간을 허용하지 않아 삽입/삭제 시마다 배열 이동이 발생함

#### ArrayList 클래스
- 배열을 이동하여 만든 리스트
- 데이터의 저장순서가 유지되고 중복을 허용
- 데이터량에 따라 공간( Capacity )가 자동으로 늘어나거나 줄어듬
- 단반향 포인터 구조로 자료에 대한 순차적인 접근에 강점이 있어 조회가 빠름
- 하지만 삽입 / 삭제가 느리다. 단, 순차적으로 추가/삭제 하는 경우에 가장 빠르다
  - 중간에 데이터를 추가/삭제시에 해당 위치 이후의 데이터들에 대한 위치 변경이 필요하기 때문


#### LinkedList 클래스
- 노드 ( 객체 )를 연결하여 리스트처럼 만든 컬렉션 ( 배열이 아님 )
- 데이터의 중간 삽입/삭제가 빈번한 경우 빠른 성능을 보장
- 임의의 요소에 대한 접근 성능이 좋지않음
- 자바의 LinkedList는 Doubly LinkedList ( 양방향 포인터 )로 이루어져 있다.
- LinkedList는 리스트 용도 이외에도 스택 , 큐 , 트리 등의 자료구조의 근간이된다
- List 인터페이스와 Queue 인터페이스를 동시에 상속받고 있어, 스택 / 큐 로서도 응용이 가능
- 실제로 LinkedList 클래스는 큐 동작과 관련된 메서드를 지원한다.

#### Vector 클래스
- ArrayList의 구형 버전 ( 내부 구성이 비슷 )
- ArrayList와 차이점은, 모든 메소드가 동기화 ( Synchronized )되어있어, Thread-Safe하다
- 구버전 자바와 호환을 위해 남겨져 있으며, 잘  쓰이지는 않는다

#### Stack 클래스
- 후입 선출 ( LIFO ) 자료구조
- 마지막에 들어온 원소가 가장 먼저 출력된다
- 데이터를 넣을때는 push 출력할때는 pop이라는 용어를 사용
- Stack은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓰임, 대신 ArrayDeque를 사용한다

## Queue 인터페이스
- 선입 선출 ( FIFO ) 자료구조
- 처음 들어온 원소가 가장 먼저 출력
- 자바에서는 Queue는 인터페이스이고, 필요에 따라 큐 컬렉션을 골라서 사용할 수 있다.

#### PriorityQuery 클래스
- 우선 순위를 가지는 큐  ( 우선순위 큐 )
- 일반적인 큐와는 조금 다르게, 원소에 우선 순위(Priority)를 부여하여 우선순위가 높은 순으로 정렬되고 출력한다.
- 수행할 작업이 여러개 있고, 시간이 제한되어 있을 때 우선순위가 높은 것 부터 수행할 때 쓰인다. ( 네트워크 제어 , 작업 스케쥴링 등 )
- 우선순의 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현해야한다.
  - compareTo() 메서드 로직에 따라 자료객체의 우선순위를 결정하는 식으로 동작되기 때문
- 저장공간으로 배열을 사용하며, 각 요소를 힙(Heap) 형태로 저장
- Null은 저장이 불가능하다.

## Deque 인터페이스
- Deque ( Double-Ended Queue )는 양쪽으로 데이터를 넣고 뺄 수 있는 큐를 말한다.
- 스택과 큐를 하나로 합쳐놓은 것과 같으며, 스택으로 사용할 수도 있고, 큐로 사용할 수도 있다.
- Deque의 조상은 Queue이며, 구현체로 ArrayDeque와 LinkedList등이 있다.

#### ArrayDeque 클래스
- 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
- 사이즈에 제한이 없다
- Null요소는 저장되지 않는다.



## Set 인터페이스
- 데이터의 중복을 허용하지 않고, 순서를 유지하지 않는 데이터의 집합 리스트
- 순서 자체가 없으므로, 인덱스로 객체를 검색해서 가져오는 get() 메서드 자체가 없다.
- 중복 저장이 불가능하기 때문에 심지어 null값도 하나만 저장이 가능하다.


#### HashSet 클래스
- 배열과 연결 노드를 결합한 자료구조 형태
- 가장 빠른 임의 검색 접근 속도를 가진다.
- 추가 , 삭제 ,검색 접근성이 모두 뛰어나다.
- 대신 순서를 전혀 예측할 수 없다.

#### LinkedHashSet 클래스
- 순서를 가지는 Set
- 추가된 순서 또는 가장 최근에 접근한 순서대로 접근가능
- 만일 중복을 제거하는 동시에 저장한 순서를 유지하고 싶다면, HashSet 대신 LinkedHashSet을 추천

#### TreeSet 클래스
- 이진 검색트리 ( Binary Search Tree )자료 구조의 형태로 데이터를 저장
- 중복을 허용하지 않고, 순서를 가지지 않는다
- 데이터를 정렬하여 저장하고 있다는 특징이있음
- 정렬,검색,범위 검색에 높은 성능


#### EnumSet 클래스
- Enum 클래스와 함께 동작하는 Set 컬렉션
- 중복되지 않은 상수 그룹을 나타내는데 사용된다
- 산술 비트 연산을 사용하여, 구현되므로 HashSet보다 훨씬 빠르며, 적은 메모리를 사용
- Enum 타입의 요소 값만 저장할 수 있고, 모든 요소들은 동일한 Enum 객체에 소속되어야 한다
- EnumSet은 추상 클래스고, 이를 상속한 RegularEnumSet 혹은 JumboEnumSet 객체를 사용한다



## Map 인터페이스
- 키( Key )와 값 ( Value )의 쌍으로 연관지어 이루어진 데이터의 집합
- 값은 중복되서 저장될 수 있지만, 키는 해당 Map에서 고유해야 한다.
- 만일 기존에 저장된 데이터와 중복된 키와 값을 저장하면 기존의 값은 없어지고, 새로운 값이 저장된다.
- 저장 순서가 유지되지 않는다.

## Map.Entry 인터페이스
- Map 인터페이스 안에 있는 내부 인터페이스
- Map에 저장되는 key-value쌍의 Node 내부 클래스가 이를 구현한다.
- Map 자료구조를 보다 객체지향적인 설계를 하도록 유도하기 위한 것


#### HashMap 클래스
- HashTable을 보완한 컬렉션
- 배열과 연결이 결합된 Hashing 형태로, 키와 값을 묶어 하나의 데이터로 저장
- 중복을 허용하지 않고, 순서를 보장하지 않는다
- 키와 값으로 null이 허용
- 추가,삭제,검색,접근성이 모두 뛰어나다
- HashMap은 비동기로 작동하기 때문에 멀티 쓰레드 환경에서 어울리지 않는다.( 대신 ConcurrentHashMap 사용 )

#### LinkedHashMap 클래스
- HashMap을 상속하기 때문에 흡사하지만, Entry들이 연결 리스트를 구성하여, 데이터의 순서를 보장
- 일반적으로 Map 자료구조는 순서를 가지지 않지만, LinkedHashMap은 들어온 순서대로 순서를 가짐

#### TreeMap 클래스
- 이진 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장 ( TreeSet과 같은 원리 )
- TreeMap은 SortedMap 인터페이스를 구현하고 있어, Key값을 기준으로 정렬되는 특징을 가짐
- 정렬된 순서로 키/값을 저장하므로, 빠른 검색 ( 특히 범위 검색 )이 가능
- 단,키와 값을 저장하는 동시에 정렬을 진행하여 저장시간이 다고 오래걸림
- 정렬되는 순서는 숫자 -> 알파벳 대문자 -> 소문자 -> 한글 순이다


#### Properties 클래스
- Properteis(String,String) 형태로 저장되는 단순화된 key-value 컬렉션
- 주로 애플리케이션의 환경 설정과 관련된 속성 파일인 .properties를 설정하는데 사용
