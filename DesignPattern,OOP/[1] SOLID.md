# SOLID 원칙
1. SRP ( Single Responsebility Principle ) 단일 책임 원칙
2. OCP ( Open Closed Principle ) 개방 폐쇄 원칙
3. LSP ( Liskove Substitution Principle) 리스코프 치환 원칙
4. ISP ( Interface Sergregation Principle ) 인터페이스 원리 원칙
5. DIP ( Dependency Inversion Principle ) 의존 역전 원칙
- SOLID 객체지향 원칙을 적용하면, 코드를 확장하고, 유지보수 관리하기가 더 쉬워지며, 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있다.



## SRP 단일 책임 원칙
> - 클래스 ( 객체 )는 단 하나의 책임만 가져야 한다는 원칙
> - 책임이란 하나의 '기능'을 담당한다라는 것으로 보면 된다.
> - 즉, 하나의 클래스는 하나의 기능을 담당하여, 하나의 책임을 수행하는데 집중하도록 클래스를 설계하라는 원칙
> - 하나의 클래스에 (기능)책임이 여러개 있다면, 기능 변경(수정)이 일어났을때 수정해야할 코드가 많아진다.
> - 최종적으로 단일 책임 원칙은 프로그램의 유지보수성을 높이기 위한 설계 기법이다.


## OCP ( 개방 폐쇄 원칙 )
> - 확장에는 열려있어야 하며, 수정에는 닫혀 있어야한다.
> - 기능 추가 요청이 오면, 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 만드는 설계 기법
>   - 확장에 열려있다 : 새로운 변경사항이 발생했을 경우 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 기능확장이 가능
>   - 변경에 닫혀있다 : 새로운 변경사항이 발생했을 때 객체를 직접적으로 수정하는것을 제한
> - 쉽게 생각하면 OCP는 추상화 사용을 통한 관계 구축을 권장하는것을 의미한다.
> - 즉, 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙

## LSP ( 리스코프 치환 원칙 )
> - 서브타입은 언제나 기반(부모)타입으로 교체할 수 있어야 한다는 원칙
> - 쉽게 말하면 다형성 원리를 이용하기 위한 원칙개념.
> - 다형성의 특징을 이용하기 위해 상위클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 통해 사용해도 동작이 의도대로 흘러가야한다.
> - 기본적으로 LSP는 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야한다.
> - 왜냐하면 부모 클래스와 동일한 수준의 선행조건을 기대하고 사용하는 프로그램 코드에서 예상 못한 문제를 일으킬 수 있기 때문

## ISP ( 인터페이스 분리 원칙 )
> - 인터페이스를 각각 사용에 맞게 끔 잘게 분리하는 것
> - SRP가 클래스의 단일 책임을 강조한다면, ISP 는 인터페이스의 단일 책임을 강조
> - SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계
> - ISP 원칙은 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표
> - ISP 원칙의 주의해야 할 점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말아야 한다.

## DIP ( 의존 역전 원칙 )
> - 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는것이 아니라, 그 대상의 상위요소 ( 추상 클래스 or 인터페이스 )로 참조하라는 원칙
> - 쉽게 이야기하면 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻
> - 의존 관계를 맺을 때 변화하기 쉬운것이나 자주 변화하는 것보다, 변화하기 어려운 것에 의존하는게 좋다.